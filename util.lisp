;;;; The MIT License (MIT)

;;;; Copyright (c) 2015 Huang Xuxing

;;;; Permission is hereby granted, free of charge, to any person obtaining a copy
;;;; of this software and associated documentation files (the "Software"), to deal
;;;; in the Software without restriction, including without limitation the rights
;;;; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
;;;; copies of the Software, and to permit persons to whom the Software is
;;;; furnished to do so, subject to the following conditions:

;;;; The above copyright notice and this permission notice shall be included in all
;;;; copies or substantial portions of the Software.

;;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
;;;; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
;;;; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
;;;; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
;;;; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;;;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
;;;; SOFTWARE.
;;;; General utilities useful in compressive sensing
;;;; Date: June 7, 2015

(in-package :cl-cs-util)

(deftype matrix (&optional type x y)
  "General 2D array."
  `(array ,type (,x ,y)))

(deftype square-matrix (&optional type x)
  "2D array with equal dimensions."
  `(array ,type (,x ,x)))

(defun list-dimensions (list depth)
  "Counts the dimension of a list."
  (loop repeat depth
       collect (length list)
       do (setf list (car list))))

(defun list-to-array (list depth)
  "Makes an array from a given list."
  (make-array (list-dimensions list depth) :initial-contents list))

(defun 1d-array-to-list (array)
  "Makes a list from an 1-dimensional array."
  (loop for i below (array-dimension array 0) collect (aref array i)))

(defun ignore-trailing-zero (array)
  "Removes an array's trailing 0s and returns a new array, assuming 0 will only appear on the tail."
  (declare (type vector array))
  (let ((len 0))
    (dovec (item array)
      (if (/= item 0)
	  (incf len)
	  (return-from ignore-trailing-zero (adjust-array array len))))))

(defun random-array (length start end)
  "Returns an array of fixnums of 'length', ranging from 'start' to 'end'."
  (declare (type fixnum length start end)
	   (optimize (speed 3) (safety 0)))
  (let ((out (make-array length :element-type 'fixnum))
	(rand (the fixnum (- end start))))
    (declare (type fixnum rand))
    (dotimes (i length)
      (setf (aref out i) (+ (the fixnum (random rand)) start)))
    out))

(defun random-matrix (row col start end)
  "Returns a matrix of size 'row' * 'col', ranging from 'start' to 'end'."
  (declare (type fixnum row col start end))
  (let ((out (make-array `(,row ,col) :element-type 'fixnum))
	(rand (the fixnum (- end start))))
    (declare (type fixnum rand))
    (loop for i from 0 to (1- row) do
	 (loop for j from 0 to (1- col) do
	      (setf (aref out i j) (+ (the fixnum (random rand)) start))))
    out))

(defmacro with-gensyms ((&rest names) &body body)
  "Expands into code that binds all names to symbols generated by (gensym)."
  `(let ,(loop for n in names collect `(,n (gensym (format nil "~a-" ',n))))
     ,@body))

(defmacro doseq ((n seq) &rest body)
  "Sequence version of 'doxxx' macros."
  `(map nil #'(lambda (,n) ,@body) ,seq))

(defmacro dovec ((var vector) &body body)
  "Vector version of 'doxxx' macros."
  `(map nil #'(lambda (,var) ,@body) ,vector))

(defun matrix-invert (matrix)
  "Returns the inverse matrix of a given matrix."
  (declare (type square-matrix matrix))
  (assert (= (array-dimension matrix 0)
	     (array-dimension matrix 1))
	  (matrix)
	  "Non-square ~D-by-~D matrix."
	  (array-dimension matrix 0)
	  (array-dimension matrix 1))
  (let* ((dim (array-dimension matrix 0))
	 (l (make-array dim :initial-element 0))
	 (m (make-array dim :initial-element 0))
	 (temp 0)
	 (det 1)
	 (out (make-array `(,dim ,dim) :initial-element 0)))
    (when (not (equal matrix out))
      (loop for i from 0 to (1- dim) do
	   (loop for j from 0 to (1- dim) do
		(setf (aref out i j) (aref matrix i j)))))
    (do ((k 0 (1+ k))
	 (maximum 0)
	 (1/max 0))
	((>= k dim))
      (setf (svref l k) k
	    (svref m k) k
	    maximum (aref out k k))
      (loop for i from k to (1- dim) do
	   (loop for j from k to (1- dim) do
		(when (> (abs (aref out i j)) (abs maximum))
		  (setf maximum (aref out i j)
			(svref l k) i
			(svref m k) j))))

      ;; Interchange rows with pivot.
      (if (> (svref l k) k)
	  (do ((j 0 (1+ j))
	       (i (svref l k)))
	      ((>= j dim))
	    (setf temp (- (aref out k j))
		  (aref out k j) (aref out i j)
		  (aref out i j) temp)))
      (if (> (svref m k) k)
	  (do ((i 0 (1+ i))
	       (j (svref m k)))
	      ((>= i dim))
	    (setf temp (- (aref out i k))
		  (aref out i k) (aref out i j)
		  (aref out i j) temp)))
      (if (equalp maximum 0)
	  (return-from matrix-invert 0))
      (setf 1/max (/ 1 maximum))
      (loop for i from 0 to (1- dim) do
	   (if (not (= i k))
	       (setf (aref out i k)
		     (* (aref out i k) (- 1/max)))))

      ;; Then reduce it.
      (loop for i from 0 to (1- dim) do
	   (when (not (= i k))
	     (setf temp (aref out i k))
	     (loop for j from 0 to (1- dim) do
		  (if (not (= j k))
		      (incf (aref out i j)
			    (* temp (aref out k j)))))))

      ;; Divide by pivot row.
      (loop for j from 0 to (1- dim) do
	   (if (not (= j k))
	       (setf (aref out k j)
		     (* (aref out k j) 1/max))))
      (setf det (* det maximum)
	    (aref out k k) 1/max))

    ;; And finally...
    (loop for n from (1- dim) downto 0 do
	 (if (> (svref l n) n)
	     (do ((j 0 (1+ j))
		  (i (svref l n)))
		 ((>= j dim))
	       (setf temp (aref out j n)
		     (aref out j n) (- (aref out j i))
		     (aref out j i) temp)))
	 (if (> (svref m n) n)
	     (do ((i 0 (1+ i))
		  (j (svref m n)))
		 ((>= i dim))
	       (setf temp (aref out n i)
		     (aref out n i) (- (aref out j i))
		     (aref out j i) temp))))
    (values out det)))

(defun matrix-determinant (matrix)
  "Returns the determinant of a given matrix."
  (declare (type matrix matrix))
  (assert (= (array-dimension matrix 0)
	     (array-dimension matrix 1))
	  (matrix)
	  "Non-square ~D-by-~D matrix."
	  (array-dimension matrix 0)
	  (array-dimension matrix 1))
  (second (multiple-value-list (matrix-invert matrix))))

(defun inner-product (vector1 vector2)
  "Returns the inner-product of two vectors."
  (declare (type vector vector1)
	   (type vector vector2))
  (assert (= (array-dimension vector1 0)
	     (array-dimension vector2 0))
	  (vector1 vector2)
	  "Size mismatch, vectors of length ~D and ~D."
	  (array-dimension vector1 0)
	  (array-dimension vector2 0))
  (let ((dim (array-dimension vector1 0))
	(result 0))
    (loop for i from 0 to (- dim 1) do
	 (incf result (* (svref vector1 i) (svref vector2 i))))
    result))

(defun matrix-rank (matrix)
  "Returns the rank of a matrix."
  (declare (type matrix matrix))
  )

(defun vector-norm (vec &key (p 2))
  "Norm function of a general vector."
  (declare (type vector vec))
  (let ((sum 0))
    (loop for i from 0 to (1- (length vec)) do
	 (incf sum (expt (aref vec i) p)))
    (expt sum (/ 1 p))))

(defun sparse-vector-norm (svec &key (p 2))
  "Norm function of a sparse vector."
  (declare (type sparse-vector svec))
  (let ((sum 0))
    (loop for i from 0 to (1- (length (sparse-vector-index svec))) do
	 (incf sum (expt (aref (sparse-vector-values svec) i) p)))
    (expt sum (/ 1 p))))

(defun vector-abs (vec)
  "Vector version of abs."
  (declare (type vector vec))
  (let* ((len (length vec))
	 (out (make-array len :initial-element 0)))
    (loop for i from 0 to (1- len) do
	 (setf (aref out i) (abs (aref vec i))))
    out))

(defun sparse-vector-abs (svec)
  "Sparse vector version of abs."
  (declare (type sparse-vector svec))
  (let* ((len (sparse-vector-len svec))
	 (vlen (length (sparse-vector-index svec)))
	 (out (make-sparse-vector :values (make-array vlen :initial-element 0)
				  :index (make-array vlen :initial-element 0)
				  :len len)))
    (loop for i from 0 to (1- vlen) do
	 (setf (aref (sparse-vector-values out) i)
	       (abs (aref (sparse-vector-values svec) i))
	       (aref (sparse-vector-index out) i)
	       (aref (sparse-vector-index svec) i)))))

(defun vector-sign (vec)
  "Vector version of sign function."
  (declare (type vector vec))
  (let* ((len (length vec))
	 (out (make-array len :initial-element 0)))
    (loop for i from 0 to (1- (length vec)) do
	 (if (> (aref vec i) 0)
	     (setf (aref out i) 1)
	     (if (< (aref vec i) 0)
		 (setf (aref out i) -1)
		 (setf (aref out i) 0))))
    out))

(defun sparse-vector-sign (svec)
  "Sparse vector version of sign function."
  (declare (type sparse-vector svec))
  (let* ((len (sparse-vector-len svec))
	 (vlen (length (sparse-vector-index svec)))
	 (out (make-sparse-vector :values (make-array vlen :initial-element 0)
				  :index (make-array vlen :initial-element 0)
				  :len len)))
    (loop for i from 0 to (1- vlen) do
	 (if (> (aref (sparse-vector-values svec) i) 0)
	     (setf (aref (sparse-vector-values out) i)
		   1
		   (aref (sparse-vector-index out) i)
		   (aref (sparse-vector-index svec) i))
	     (setf (aref (sparse-vector-values out) i)
		   -1
		   (aref (sparse-vector-index out) i)
		   (aref (sparse-vector-index svec) i))))
    out))
